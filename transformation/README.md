# Data Transformation with CUE

The process of conversion of one, usually small and high-level data model into another, verbose and low-level data model. The low-level data model could be the actual intended device configuration, if its API supports structured data, or it can be used to generate the final configuration using a template.

0. Starting point

Any existing Ansible playbook that implements data transformation. Most often this is accomplished with ["jinja programming"]((https://twitter.com/privateip/status/1174410756181413889)) using one of the two approaches:

* By creating a structured document (e.g. YAML) [using string interpolation](https://gitlab.com/nvidia-networking/systems-engineering/poc-support/cumulus_ansible_modules-nvue/-/blob/main/roles/nvue/templates/features/bgp.j2).
* By manipulating data structures [using Jinja's expression statements](https://github.com/aristanetworks/ansible-avd/blob/devel/ansible_collections/arista/avd/roles/eos_designs/templates/underlay/vlans.j2) (e.g. `set` and `do` tags).

The following example is based on the MLAG configuration from Arista's [ansible-avd](https://github.com/aristanetworks/ansible-avd) repository.

1. Import high-level data model into CUE

Assuming you can collate all host variables into a single file, the import can be done with a single command.

```bash
cue import --outfile input.cue -p main -f group_vars/all.yml
```

2. Write the output CUE struct

The resulting data struct can be built using CUE's built-in expressions (e.g. interpolation, comprehension, conditionals, loops etc). Here's an example of how MLAG configuration can be generated with CUE. 

```cue
#inventory: ["dc1-leaf1a", "dc1-leaf1b"]

config: {
	for device in #inventory {
		let input = avd_switch_facts[device].switch

		"\(device)": {
			mlag_configuration: {
				domain_id:       input.group
				local_interface: "Vlan\(input.mlag_peer_vlan)"
				peer_address:    input.mlag_peer_ip & net.IPv4
				peer_link:       "Port-Channel\(input.mlag_port_channel_id)"
			}

			router_bgp: {
				let bgp = input.bgp_peer_groups.mlag_ipv4_underlay_peer
				
				peer_groups: "\(bgp.name)": {
					type:           "ipv4"
					remote_as:      input.bgp_as
					next_hop_self:  true
					description:    input.mlag_peer
					password:       bgp.password
					maximum_routes: 12000
					send_community: "all"
					route_map_in:   "RM-MLAG-PEER-IN"
					struct_cfg:     bgp.structured_config
				}
				address_family_ipv6: peer_groups: "\(bgp.name)": activate: true
				address_family_ipv4: peer_groups: "\(bgp.name)": activate: true
				neighbors: "\(input.mlag_peer_l3_ip & net.IPv4)": {
					peer_group:  "\(bgp.name)"
					description: input.mlag_peer
				}
			}
		}
	}
}
```


3. Save the generated data model

The resulting data structs are designed to be used as input for `ansible-avd`'s jinja templates. They can be used directly with Jinja, as demonstrated in the [Jinja readme](../jinja/README.md), or they can be saved locally.

```cue
import (
	"encoding/json"
	"tool/file"
)

inventory: #inventory

command: "transform": {
	for _, device in inventory {
		(device): {
			save: file.Create & {
				filename: "./out/\(device).json"
				contents: json.Marshal(config[device])
			}
		}
	}
}
```

Thanks to CUE's guarantees, we can be sure that both the input and output data structures are fully populated and structuraly correct, thus minimising the likelihood of failing during template instantiation.

---

Using `dyff` to compare two structured data models. Comparing the YAML file generated by Jinja programming and the JSON file generated by CUE:

```
dyff between out/dc1-leaf1a.yml out/dc1-leaf1a.json
```